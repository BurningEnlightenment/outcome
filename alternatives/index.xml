<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Review of Outcome Alternatives on Outcome documentation</title>
    <link>https://ned14.github.io/outcome/alternatives/</link>
    <description>Recent content in Review of Outcome Alternatives on Outcome documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 16 Dec 2021 11:42:04 +0000</lastBuildDate>
    
	<atom:link href="https://ned14.github.io/outcome/alternatives/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C&#43;&#43; exception throws</title>
      <link>https://ned14.github.io/outcome/alternatives/exceptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/alternatives/exceptions/</guid>
      <description>(Note that we assume a table-based EH implementation here, a SJLJ EH implementaton would be a lot more even with Outcome. Table-based EH implementations are almost universal on x64, ARM and AArch64 targets).
C++ exception throws came in the original C++ 98 standard &amp;ndash; at that time, not all the major compilers implemented them yet, and several of those who did did not have efficient implementations, plus in the original days some compiler vendors still patented things like EH implementation techniques to try and maintain a competitive advantage over rival compilers.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; error codes</title>
      <link>https://ned14.github.io/outcome/alternatives/error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/alternatives/error_code/</guid>
      <description>std::error_code came originally from boost::error_code which was designed around 2008 as part of implementing Filesystem and Networking. They are a simple trivially copyable type offering improved type safety and functionality over C enumerations. You can read more about how std::error_code works here. They were standardised in the C++ 11 standard.
Pros:
 Predictable runtime overhead on the happy path.
 Unbiased syntax equal for both success and failure requiring explicit code written to handle both.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; expected</title>
      <link>https://ned14.github.io/outcome/alternatives/expected/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/alternatives/expected/</guid>
      <description>std::expected&amp;lt;T, E&amp;gt; came originally from an experimental monadic and generic programming library outside of Boost written by Boost and WG21 developers around 2013. Before Outcome v1, I deployed the then Expected into a large codebase and I was dismayed with the results, especially on build times. You can read here how those experiences led me to develop Outcome v1.
std::expected&amp;lt;T, E&amp;gt; is a constrained variant type with a strong preference for the successful type T which it models like a std::optional&amp;lt;T&amp;gt;.</description>
    </item>
    
  </channel>
</rss>